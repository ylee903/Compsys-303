// main.c  — minimal 1ms scheduler that calls generated pacemaker code

#include "system.h"
#include "alt_types.h"
#include "sys/alt_irq.h"

#include "altera_avalon_timer_regs.h"   // IOWR_* & timer regs

#include "Pacemaker.h"   // generated by KIELER (has tick(TickData*))
#include "timing.h"      // your timing values

// ---- 1ms tick flag (avoid name clash with generated tick(...) function)
static volatile int g_tick_flag = 0;

// ---- Timer ISR: clear timeout + set flag
static void timer_isr(void* context) {
    // acknowledge timer interrupt
    IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, 0);
    g_tick_flag = 1;
}

int main(void) {
    // --------- Setup 1ms hardware timer ----------
    // stop timer
    IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, 0x8);

    // compute 1ms period from CPU clock
    const alt_u32 cpu_hz    = ALT_CPU_FREQ;        // from system.h (e.g., 50_000_000)
    const alt_u32 ticks_1ms = cpu_hz / 1000;       // e.g., 50_000 @ 50MHz

    // load period (low, high)
    IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_0_BASE,  (ticks_1ms & 0xFFFF));
    IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_0_BASE, ((ticks_1ms >> 16) & 0xFFFF));

    // register ISR
    alt_ic_isr_register(
        TIMER_0_IRQ_INTERRUPT_CONTROLLER_ID,
        TIMER_0_IRQ,
        timer_isr,
        NULL,
        NULL);

    // start: ITO (bit0) | CONT (bit1) | START (bit2)  -> 0b111 = 0x7
    IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, 0x7);

    // --------- Generated pacemaker state ----------
    // The KIELER C generator declares `tick(TickData* d)` in Pacemaker.h.
    // We don't need to touch fields yet; zero-init is fine for a compile/test.
    TickData d;
    // zero the struct so all internal state starts clean
    for (unsigned i = 0; i < sizeof(TickData); ++i) ((volatile char*)&d)[i] = 0;

    // --------- Main 1ms loop ----------
    while (1) {
        if (g_tick_flag) {
            g_tick_flag = 0;

            // TODO: set inputs on d (AS/VS) before calling tick(&d)
            // e.g., d.AS = ...; d.VS = ...;

            tick(&d);   // call the generated SCCharts step once per ms

            // TODO: read outputs from d (AP/VP) and drive LEDs or UART
            // e.g., if (d.AP) ...; if (d.VP) ...;
        }
        // optional: do low-priority background work here
    }
}
