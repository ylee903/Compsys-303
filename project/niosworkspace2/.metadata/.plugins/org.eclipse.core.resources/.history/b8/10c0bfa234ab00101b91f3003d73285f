#include "Pacemaker_C.h"
#include <string.h>

/* -------- helpers -------- */
static inline void dec_if_pos(int* t){ if(*t>0)--(*t); }

/* -------- lifecycle -------- */
void PMc_init(PacemakerC* s){
  if(!s) return;
  memset(s,0,sizeof(*s));

  /* Start with V-side timers so we have immediate backup if needed */
  s->AEI = AEI_VALUE;  /* expect an AS within AEI after a V */
  s->LRI = LRI_VALUE;  /* expect next V within LRI */
  s->URI = 0;          /* allow pacing at start */

  s->seen_AS_since_last_V = 0;
  s->led_pulse_ms = 0;
}

void PMc_set_led_pulse_ms(PacemakerC* s,int ms){
  if(!s) return; s->led_pulse_ms = (ms>0?ms:0);
}

int PMc_start_1ms_alarm(void){ return 0; } /* no hardware timer */

/* Caller sets inputs before each tick */
void PMc_set_senses(PacemakerC* s,int AS_raw,int VS_raw){
  if(!s) return;
  s->AS_raw = AS_raw?1:0;
  s->VS_raw = VS_raw?1:0;
}

/* -------- one 1 ms step -------- */
static void PMc_tick_1ms(PacemakerC* s){
  /* clear one-tick outputs */
  s->AP = 0; s->VP = 0;

  /* timers */
  dec_if_pos(&s->AVI);
  dec_if_pos(&s->AEI);
  dec_if_pos(&s->PVARP);
  dec_if_pos(&s->VRP);
  dec_if_pos(&s->LRI);
  dec_if_pos(&s->URI);
  dec_if_pos(&s->AP_led_ms);
  dec_if_pos(&s->VP_led_ms);

  /* gate senses by refractory */
  s->AS = (s->AS_raw && s->PVARP==0) ? 1:0;   /* PVARP gates AS */
  s->VS = (s->VS_raw && s->VRP  ==0) ? 1:0;   /* VRP   gates VS */

  /* ===== Handle intrinsic VS first (normal heart → often inhibits pacing) ===== */
  if(s->VS){
    /* a ventricular depolarization occurred */
    s->VRP  = VRP_VALUE;
    s->PVARP= PVARP_VALUE;         /* PVARP starts after any V (VS/VP) */
    s->AEI  = AEI_VALUE;           /* expect next A */
    s->LRI  = LRI_VALUE;           /* expect next V within this */
    s->URI  = URI_VALUE;           /* upper rate gate */

    s->seen_AS_since_last_V = 0;
    s->pending_vp_avi = 0;
    s->pending_vp_lri = 0;
    s->AVI = 0;                    /* close any running AVI */
  }

  /* ===== Handle atrial events (sensed or paced) ===== */
  if(s->AS){
    /* Start A→V tracking window: we will VP only if VS fails to appear in time */
    s->AVI = AVI_VALUE;
    s->seen_AS_since_last_V = 1;
  }

  /* ===== Atrial backup (AEI) — rarely used in a healthy heart ===== */
  if(s->AEI==0 && s->seen_AS_since_last_V==0){
    /* No AS since last V → deliver AP as backup */
    s->AP = 1;
    s->AP_fired = 1;
    s->AP_led_ms = s->led_pulse_ms;

    /* AP behaves like an A event for V-tracking (does NOT start PVARP) */
    s->AVI = AVI_VALUE;
    s->seen_AS_since_last_V = 1;

    /* After an AP we still rely on VS within AVI; otherwise VP below */
  }

  /* ===== Ventricular pacing logic (inhibited unless needed) ===== */
  /* 1) AVI-based: if we saw an A (AS/AP) and VS didn't show up in time */
  if(s->seen_AS_since_last_V && s->AVI==0){
    if(s->URI==0){
      s->VP = 1;
      s->VP_fired = 1;
      s->VP_led_ms = s->led_pulse_ms;

      /* Post-V timers */
      s->VRP  = VRP_VALUE;
      s->PVARP= PVARP_VALUE;
      s->AEI  = AEI_VALUE;
      s->LRI  = LRI_VALUE;
      s->URI  = URI_VALUE;

      s->seen_AS_since_last_V = 0;
      s->pending_vp_avi = 0;
    }else{
      s->pending_vp_avi = 1;  /* owe a VP once URI clears */
    }
  }

  /* 2) LRI-based: ensure a minimum ventricular rate (backup if long pause) */
  if(s->LRI==0){
    if(s->URI==0){
      s->VP = 1;
      s->VP_fired = 1;
      s->VP_led_ms = s->led_pulse_ms;

      s->VRP  = VRP_VALUE;
      s->PVARP= PVARP_VALUE;
      s->AEI  = AEI_VALUE;
      s->LRI  = LRI_VALUE;
      s->URI  = URI_VALUE;

      s->seen_AS_since_last_V = 0;
      s->pending_vp_lri = 0;
      s->AVI = 0;   /* close any stale AVI */
    }else{
      s->pending_vp_lri = 1;
    }
  }

  /* Late release if URI was blocking */
  if(s->URI==0){
    if(s->pending_vp_avi && s->seen_AS_since_last_V){
      /* deliver the owed VP for failed A→V */
      s->VP = 1;
      s->VP_fired = 1;
      s->VP_led_ms = s->led_pulse_ms;

      s->VRP = VRP_VALUE; s->PVARP = PVARP_VALUE;
      s->AEI = AEI_VALUE; s->LRI   = LRI_VALUE; s->URI = URI_VALUE;

      s->seen_AS_since_last_V = 0;
      s->pending_vp_avi = 0;
      s->AVI = 0;
    }else if(s->pending_vp_lri){
      /* deliver the owed VP for long V–V pause */
      s->VP = 1;
      s->VP_fired = 1;
      s->VP_led_ms = s->led_pulse_ms;

      s->VRP = VRP_VALUE; s->PVARP = PVARP_VALUE;
      s->AEI = AEI_VALUE; s->LRI   = LRI_VALUE; s->URI = URI_VALUE;

      s->seen_AS_since_last_V = 0;
      s->pending_vp_lri = 0;
      s->AVI = 0;
    }
  }

  /* consume raw one-ms pulses */
  s->AS_raw = 0;
  s->VS_raw = 0;
}

void PMc_run_for_elapsed_ms(PacemakerC* s){
  if(!s) return;
  PMc_tick_1ms(s);
}

/* -------- outputs / status -------- */
void PMc_poll_and_clear_pulses(PacemakerC* s,int* AP_any,int* VP_any){
  if(AP_any) *AP_any = s->AP_fired;
  if(VP_any) *VP_any = s->VP_fired;
  if(!s) return;
  s->AP_fired = 0;
  s->VP_fired = 0;
}

int PMc_led_AP_on(const PacemakerC* s){ return (s && s->AP_led_ms>0)?1:0; }
int PMc_led_VP_on(const PacemakerC* s){ return (s && s->VP_led_ms>0)?1:0; }
