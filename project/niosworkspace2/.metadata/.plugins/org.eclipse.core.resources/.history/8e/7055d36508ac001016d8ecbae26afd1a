#include <string.h>
#include <stdio.h>
#include <sys/alt_alarm.h>
#include <sys/alt_irq.h>
#include <altera_avalon_pio_regs.h>
#include <system.h>

#include "Pacemaker_C.h"

/* ==================== Module-local state ==================== */
static PacemakerC* s_pm_ptr = NULL;
static alt_alarm    s_tick_alarm;

/* ==================== Helpers ==================== */
static inline int just_expired(int before, int after){ return (before > 0) && (after == 0); }

static void handle_atrial_event(PacemakerC* s, int paced){
  (void)paced;
  /* AEI disarms on any atrial event (AS or AP) */
  s->AEI = 0;

  /* If PVARP is FALSE, (AS or AP) â†’ arm AVI */
  if (s->PVARP == 0){
    s->AVI = AVI_VALUE;
  }
}

static void handle_ventricular_event(PacemakerC* s, int paced){
  (void)paced;

  /* Any V-event cancels a pending fake VP */
  s->vp_waiting_for_URI = 0;

  /* After a V-event, arm/reset: AEI, VRP, LRI, URI, and PVARP */
  s->AEI   = AEI_VALUE;
  s->VRP   = VRP_VALUE;
  s->LRI   = LRI_VALUE;
  s->URI   = URI_VALUE;
  s->PVARP = PVARP_VALUE;
}

/* Schedule "fake VP": will actually pace when URI==0 unless a VS/VP happens first */
static void schedule_fake_VP(PacemakerC* s){
  s->vp_waiting_for_URI = 1;
}

/* Actually fire a VP (one-shot) */
static void fire_VP(PacemakerC* s){
  s->VP_fired  = 1;
  s->VP_led_ms = s->led_pulse_ms;
  handle_ventricular_event(s, /*paced=*/1);
}

/* Actually fire an AP (one-shot) */
static void fire_AP(PacemakerC* s){
  s->AP_fired  = 1;
  s->AP_led_ms = s->led_pulse_ms;
  handle_atrial_event(s, /*paced=*/1);
}

/* ==================== 1 ms TICK ISR ==================== */
static alt_u32 PMc_tick_isr(void* context) {
  PacemakerC* s = (PacemakerC*)context;
  if (!s) return 1;

  /* -------- LED stretch -------- */
  if (s->AP_led_ms > 0) s->AP_led_ms--;
  if (s->VP_led_ms > 0) s->VP_led_ms--;

  /* -------- Decrement timers -------- */
  int AVI_before   = s->AVI;
  int AEI_before   = s->AEI;
  int PVARP_before = s->PVARP;
  int VRP_before   = s->VRP;
  int LRI_before   = s->LRI;
  int URI_before   = s->URI;

  if (s->AVI   > 0) s->AVI--;
  if (s->AEI   > 0) s->AEI--;
  if (s->PVARP > 0) s->PVARP--;
  if (s->VRP   > 0) s->VRP--;
  if (s->LRI   > 0) s->LRI--;
  if (s->URI   > 0) s->URI--;

  /* -------- Timer expiries -> actions -------- */

  /* AEI expiry -> AP once (do NOT auto-restart AEI) */
  if (just_expired(AEI_before, s->AEI)) {
    fire_AP(s);
  }

  /* AVI expiry -> schedule fake VP once (do NOT fire here if URI is blocking) */
  if (just_expired(AVI_before, s->AVI)) {
    schedule_fake_VP(s);
  }

  /* LRI expiry -> schedule fake VP once (backup rate) */
  if (just_expired(LRI_before, s->LRI)) {
    schedule_fake_VP(s);
  }

  /* Pending fake VP logic:
     - Cancel if a VS was accepted (outside VRP) or a VP fired since we scheduled.
     - Otherwise, if URI==0, deliver VP now; if URI>0, keep waiting. */
  if (s->vp_waiting_for_URI) {
    /* If a sensed V was accepted this ms (gated VS==1) or we already fired VP, cancel */
    if (s->VS || s->VP_fired) {
      s->vp_waiting_for_URI = 0;  /* conduction happened; no need to pace */
    } else if (s->URI == 0) {
      fire_VP(s);
      s->vp_waiting_for_URI = 0;
    } /* else: still within URI -> keep waiting */
  }

  /* Clear one-tick gated senses at the end of a tick window */
  s->AS = 0;
  s->VS = 0;

  return 1; /* re-schedule in 1 ms */
}

/* ==================== Optional VS IRQ (hardware) ==================== */
#ifdef VENTRICULAR_SENSE_BASE
static void PMc_VS_isr(void* context) {
  (void)context;
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(VENTRICULAR_SENSE_BASE, 0x1);
  if (s_pm_ptr) {
    /* We only set VS_raw here; it will be gated & handled in PMc_set_senses */
    s_pm_ptr->VS_raw = 1;
  }
}
#endif

/* ==================== Public API ==================== */

void PMc_init(PacemakerC* s) {
  memset(s, 0, sizeof(*s));
  s->led_pulse_ms = 25;

  /* All timers start disarmed (0). The first real VS/VP will arm AEI/LRI/etc. */
}

int PMc_start_1ms_alarm(void) {
  return 0; /* Deprecated; kept for compatibility */
}

static int PMc_start_1ms_alarm_with_state(PacemakerC* s) {
  if (!s) return -1;

  s_pm_ptr = s;

  int status = alt_alarm_start(&s_tick_alarm, 1, PMc_tick_isr, s);
  if (status != 0) {
    printf("[ERR] Failed to start 1ms alarm: %d\n", status);
    return status;
  }

#ifdef VENTRICULAR_SENSE_BASE
  IOWR_ALTERA_AVALON_PIO_IRQ_MASK(VENTRICULAR_SENSE_BASE, 0x1);
  IOWR_ALTERA_AVALON_PIO_EDGE_CAP(VENTRICULAR_SENSE_BASE, 0x1);
  status = alt_ic_isr_register(
      VENTRICULAR_SENSE_IRQ_INTERRUPT_CONTROLLER_ID,
      VENTRICULAR_SENSE_IRQ,
      PMc_VS_isr, NULL, NULL);
  if (status != 0) {
    printf("[WARN] VS IRQ register failed: %d (continuing without IRQ)\n", status);
  }
#endif

  printf("[OK ] C-mode 1ms ISR started\n");
  fflush(stdout);
  return 0;
}

int PMc_enable_interrupts(PacemakerC* s) { return PMc_start_1ms_alarm_with_state(s); }

void PMc_set_led_pulse_ms(PacemakerC* s, int ms) { if (s) s->led_pulse_ms = ms; }

/* Main-thread entry: deliver raw one-tick senses, gate them, and execute
   the immediate parts of your spec that depend on *arrival* of senses. */
void PMc_set_senses(PacemakerC* s, int AS_val, int VS_val) {
  if (!s) return;

  /* Latch raw for visibility */
  s->AS_raw = AS_val ? 1 : 0;
  s->VS_raw = VS_val ? 1 : 0;

  /* Gate through refractory */
  int AS_gated = (AS_val && (s->PVARP == 0)) ? 1 : 0;
  int VS_gated = (VS_val && (s->VRP   == 0)) ? 1 : 0;

  s->AS = AS_gated;
  s->VS = VS_gated;

  /* === Your rules ===
     1) IF (AS or AP) AND (PVARP is FALSE) -> Reset+ARM AVI
        (AP path is handled inside fire_AP/handle_atrial_event)
        Here we only respond to *sensed* atrial events. */
  if (AS_gated) {
    handle_atrial_event(s, /*paced=*/0);
  }

  /* 2) IF (VS or VP) AND (VRP is FALSE) -> reset+arm AEI and VRP and LRI
        Also (clinically correct) arm PVARP and URI on V-events.
        (VP path is handled inside fire_VP/handle_ventricular_event)
     */
  if (VS_gated) {
    handle_ventricular_event(s, /*paced=*/0);
  }
}

/* Timing handled in ISR; keep for API compatibility */
void PMc_run_for_elapsed_ms(PacemakerC* s){ (void)s; }

void PMc_poll_and_clear_pulses(PacemakerC* s, int* out_AP, int* out_VP) {
  if (!s) return;
  if (out_AP) *out_AP = s->AP_fired;
  if (out_VP) *out_VP = s->VP_fired;

  /* Clear one-shots after consumer reads them */
  s->AP_fired = 0;
  s->VP_fired = 0;
}

int PMc_led_AP_on(const PacemakerC* s) { return (s && s->AP_led_ms > 0) ? 1 : 0; }
int PMc_led_VP_on(const PacemakerC* s) { return (s && s->VP_led_ms > 0) ? 1 : 0; }
