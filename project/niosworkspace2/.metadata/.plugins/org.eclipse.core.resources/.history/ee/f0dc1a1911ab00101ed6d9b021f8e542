// =============================================
// File: Pacemaker_C.h
// =============================================
#ifndef PACEMAKER_C_H
#define PACEMAKER_C_H


#include <alt_types.h>
#include "timing.h" // AVI_VALUE, AEI_VALUE, PVARP_VALUE, VRP_VALUE, LRI_VALUE, URI_VALUE


#ifdef __cplusplus
extern "C" {
#endif


// Hand-written DDD pacemaker state for C mode (SW0 = 1)
typedef struct {
// Inputs for current ms (raw/ungated). Caller sets these before stepping.
int AS_raw; // atrial sense (1 = a-sensed at this ms)
int VS_raw; // ventricular sense (1 = v-sensed at this ms)


// Internal, gated senses (after refractory)
int AS; // becomes 1 for this ms if AS_raw && !PVARP
int VS; // becomes 1 for this ms if VS_raw && !VRP


// One-ms pace pulses generated by the algorithm (set during a tick)
int AP; // atrial pace at this ms
int VP; // ventricular pace at this ms


// Sticky flags to report if a pace happened in any processed ms since last poll
int AP_fired;
int VP_fired;


// Timers (countdown, ms; 0 = expired/not running)
int AVI, AEI, PVARP, VRP, LRI, URI;


// Control flags
int seen_AS_since_last_V; // true if any A-event (AS or AP) since the last V-event
int vp_waiting_for_URI; // we owe a VP but are blocked by URI


// LED stretch (visual only, does not affect protocol)
int led_pulse_ms; // configurable, default 25 ms
int AP_led_ms; // remaining ms to hold AP LED on
int VP_led_ms; // remaining ms to hold VP LED on
} PacemakerC;


// ---- Lifecycle ----
void PMc_init(PacemakerC* s);
void PMc_set_led_pulse_ms(PacemakerC* s, int ms);


// ---- 1 ms timing ----
// Start a 1ms alarm that increments an internal tick counter (module-local ISR)
int PMc_start_1ms_alarm(void);
// Run the algorithm once per elapsed ms (consumes any accumulated ISR ticks)
void PMc_run_for_elapsed_ms(PacemakerC* s);


// ---- Inputs for next ms window ----
// Caller sets raw senses before calling PMc_run_for_elapsed_ms(). These are
// treated as single-ms pulses when set to 1.
static inline void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw){ s->AS_raw = AS_raw; s->VS_raw = VS_raw; }


// ---- Outputs / status ----
// After PMc_run_for_elapsed_ms(), query whether any AP/VP fired during the
// processed window; this also clears the sticky flags.
void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any);


// LED helpers: whether LEDs should currently be on (with stretch applied)
int PMc_led_AP_on(const PacemakerC* s);
int PMc_led_VP_on(const PacemakerC* s);


#ifdef __cplusplus
#endif // PACEMAKER_C_H
