/* pacemaker_c_single.h — header+impl do-nothing stub
   Usage:
     // In most files:
     #include "pacemaker_c_single.h"
     // In exactly ONE .c file:
     #define PACEMAKER_C_IMPL
     #include "pacemaker_c_single.h"
*/

#ifndef PACEMAKER_C_SINGLE_H
#define PACEMAKER_C_SINGLE_H

#include <stdint.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Safe defaults if timing.h isn't present */
#ifndef AVI_VALUE
#define AVI_VALUE   300
#endif
#ifndef AEI_VALUE
#define AEI_VALUE   800
#endif
#ifndef PVARP_VALUE
#define PVARP_VALUE 50
#endif
#ifndef VRP_VALUE
#define VRP_VALUE   150
#endif
#ifndef LRI_VALUE
#define LRI_VALUE   950
#endif
#ifndef URI_VALUE
#define URI_VALUE   900
#endif

/* Public state (field names preserved so existing code compiles) */
typedef struct {
  /* Inputs (caller sets before stepping) */
  int AS_raw;
  int VS_raw;

  /* Gated senses (unused in stub) */
  int AS;
  int VS;

  /* One-ms pace pulses (never fire in stub) */
  int AP;
  int VP;

  /* Sticky flags (never set in stub) */
  int AP_fired;
  int VP_fired;

  /* Timers (not used in stub) */
  int AVI, AEI, PVARP, VRP, LRI, URI;

  /* Control/debug flags (not used in stub) */
  int seen_AS_since_last_V;
  int vp_waiting_for_URI;
  int pending_vp_avi;
  int pending_vp_lri;

  /* LED stretch (not used in stub) */
  int led_pulse_ms;
  int AP_led_ms;
  int VP_led_ms;
} PacemakerC;

/* API (signatures unchanged) */
void PMc_init(PacemakerC* s);
void PMc_set_led_pulse_ms(PacemakerC* s, int ms);
int  PMc_start_1ms_alarm(void);
void PMc_run_for_elapsed_ms(PacemakerC* s);
void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw);
void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any);
int  PMc_led_AP_on(const PacemakerC* s);
int  PMc_led_VP_on(const PacemakerC* s);

#ifdef __cplusplus
} /* extern "C" */
#endif
#endif /* PACEMAKER_C_SINGLE_H */

/* ================= Implementation (compiled once where PACEMAKER_C_IMPL is defined) ================= */
#ifdef PACEMAKER_C_IMPL

void PMc_init(PacemakerC* s) {
  if (!s) return;
  memset(s, 0, sizeof(*s));
  s->led_pulse_ms = 25;

  /* Seed timer fields so code reading them doesn't crash; stub ignores them. */
  s->AVI   = AVI_VALUE;
  s->AEI   = AEI_VALUE;
  s->PVARP = PVARP_VALUE;
  s->VRP   = VRP_VALUE;
  s->LRI   = LRI_VALUE;
  s->URI   = URI_VALUE;
}

void PMc_set_led_pulse_ms(PacemakerC* s, int ms) {
  if (!s) return;
  s->led_pulse_ms = (ms > 0) ? ms : 1;
}

/* No ISR/timer in stub; return 0 to indicate “ok-ish”. */
int PMc_start_1ms_alarm(void) {
  return 0;
}

/* Does not advance any logic. */
void PMc_run_for_elapsed_ms(PacemakerC* s) {
  (void)s;
}

/* Store raw senses; do not generate anything. */
void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw) {
  if (!s) return;
  s->AS_raw = AS_raw ? 1 : 0;
  s->VS_raw = VS_raw ? 1 : 0;

  /* Clear gated & outputs since stub does nothing */
  s->AS = s->VS = 0;
  s->AP = s->VP = 0;
}

/* Report-and-clear sticky pulses (always 0 in stub). */
void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any) {
  if (!s) return;
  if (AP_any) *AP_any = s->AP_fired;
  if (VP_any) *VP_any = s->VP_fired;
  s->AP_fired = 0;
  s->VP_fired = 0;
}

/* LEDs never on in stub. */
int PMc_led_AP_on(const PacemakerC* s) { (void)s; return 0; }
int PMc_led_VP_on(const PacemakerC* s) { (void)s; return 0; }

#endif /* PACEMAKER_C_IMPL */
