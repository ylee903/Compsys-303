#ifndef PACEMAKER_C_H
#define PACEMAKER_C_H

#include <alt_types.h>
#include "timing.h"  /* AVI_VALUE, AEI_VALUE, PVARP_VALUE, VRP_VALUE, LRI_VALUE, URI_VALUE */

#ifdef __cplusplus
extern "C" {
#endif

/* Hand-written DDD pacemaker state for C mode (SW0 = 1) */
typedef struct {
  /* Inputs for current ms (raw/ungated). Caller sets these before stepping. */
  int AS_raw;
  int VS_raw;

  /* Gated senses (after refractory) */
  int AS;
  int VS;

  /* One-ms pace pulses generated by the algorithm */
  int AP;
  int VP;

  /* Sticky flags to report if a pace happened since last poll */
  int AP_fired;
  int VP_fired;

  /* Timers (countdown, ms; 0 = expired/not running) */
  int AVI, AEI, PVARP, VRP, LRI, URI;

  /* Control flags */
  int seen_AS_since_last_V;    /* true if AS/AP since last V */
  int vp_waiting_for_URI;      /* kept for backward compatibility (derived) */

  /* Distinct pending-reasons for URI hold-off */
  int pending_vp_avi;          /* we owe a VP due to AVI expiry */
  int pending_vp_lri;          /* we owe a VP due to LRI expiry */

  /* LED stretch (visual only) */
  int led_pulse_ms;            /* default 25 ms */
  int AP_led_ms;
  int VP_led_ms;
} PacemakerC;

/* ---- Lifecycle ---- */
void PMc_init(PacemakerC* s);
void PMc_set_led_pulse_ms(PacemakerC* s, int ms);

/* ---- 1 ms timing ---- */
/* Start a 1ms alarm that increments an internal tick counter (module-local ISR) */
int  PMc_start_1ms_alarm(void);
/* Run the algorithm once per elapsed ms (consumes accumulated ISR ticks) */
void PMc_run_for_elapsed_ms(PacemakerC* s);

/* ---- Inputs for next ms window ---- */
void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw);

/* ---- Outputs / status ---- */
void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any);
int  PMc_led_AP_on(const PacemakerC* s);
int  PMc_led_VP_on(const PacemakerC* s);

#ifdef __cplusplus
}
#endif

#endif /* PACEMAKER_C_H */
