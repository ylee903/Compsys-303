/* Pacemaker_C.c â€” single-file "header+impl" do-nothing stub
   Keeps the public API & types so the rest of your code compiles.
   No Nios II / ALT headers. No timers. No UART. No hardware. */

#ifndef PACEMAKER_C_SINGLEFILE_H
#define PACEMAKER_C_SINGLEFILE_H

#include <stdint.h>
#include <string.h>

/* If timing values aren't coming from timing.h anymore, define safe defaults here. */
#ifndef AVI_VALUE
#define AVI_VALUE   300
#endif
#ifndef AEI_VALUE
#define AEI_VALUE   800
#endif
#ifndef PVARP_VALUE
#define PVARP_VALUE 50
#endif
#ifndef VRP_VALUE
#define VRP_VALUE   150
#endif
#ifndef LRI_VALUE
#define LRI_VALUE   950
#endif
#ifndef URI_VALUE
#define URI_VALUE   900
#endif

/* --- Public state struct (unchanged field names so your code keeps compiling) --- */
typedef struct {
  /* Inputs (caller sets before stepping) */
  int AS_raw;
  int VS_raw;

  /* Gated senses (unused in stub) */
  int AS;
  int VS;

  /* One-ms pace pulses (never fire in stub) */
  int AP;
  int VP;

  /* Sticky flags (never set in stub) */
  int AP_fired;
  int VP_fired;

  /* Timers (not used in stub) */
  int AVI, AEI, PVARP, VRP, LRI, URI;

  /* Control/debug flags (not used in stub) */
  int seen_AS_since_last_V;
  int vp_waiting_for_URI;
  int pending_vp_avi;
  int pending_vp_lri;

  /* LED stretch (not used in stub) */
  int led_pulse_ms;
  int AP_led_ms;
  int VP_led_ms;
} PacemakerC;

/* ---- API prototypes (same signatures as before) ---- */
void PMc_init(PacemakerC* s);
void PMc_set_led_pulse_ms(PacemakerC* s, int ms);
int  PMc_start_1ms_alarm(void);
void PMc_run_for_elapsed_ms(PacemakerC* s);
void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw);
void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any);
int  PMc_led_AP_on(const PacemakerC* s);
int  PMc_led_VP_on(const PacemakerC* s);

#endif /* PACEMAKER_C_SINGLEFILE_H */


/* ================= Implementation (no hardware, no timers) ================= */

void PMc_init(PacemakerC* s) {
  if (!s) return;
  memset(s, 0, sizeof(*s));
  s->led_pulse_ms = 25;
  /* Seed some timer values (not used by stub) */
  s->AVI   = AVI_VALUE;
  s->AEI   = AEI_VALUE;
  s->PVARP = PVARP_VALUE;
  s->VRP   = VRP_VALUE;
  s->LRI   = LRI_VALUE;
  s->URI   = URI_VALUE;
}

void PMc_set_led_pulse_ms(PacemakerC* s, int ms) {
  if (!s) return;
  s->led_pulse_ms = (ms > 0) ? ms : 1;
}

/* In the stub, there is no ISR; return 0 (success-ish) and do nothing. */
int PMc_start_1ms_alarm(void) {
  return 0;
}

/* In the stub, we do not advance any logic. */
void PMc_run_for_elapsed_ms(PacemakerC* s) {
  (void)s;
}

/* Just store the raw senses; nothing is generated from them in the stub. */
void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw) {
  if (!s) return;
  s->AS_raw = AS_raw ? 1 : 0;
  s->VS_raw = VS_raw ? 1 : 0;
  /* Clear gated & outputs since stub does nothing */
  s->AS = s->VS = 0;
  s->AP = s->VP = 0;
}

/* Report-and-clear sticky pulses (always 0 in stub). */
void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any) {
  if (!s) return;
  if (AP_any) *AP_any = s->AP_fired;
  if (VP_any) *VP_any = s->VP_fired;
  s->AP_fired = 0;
  s->VP_fired = 0;
}

/* LEDs never on in stub. */
int PMc_led_AP_on(const PacemakerC* s) { (void)s; return 0; }
int PMc_led_VP_on(const PacemakerC* s) { (void)s; return 0; }
