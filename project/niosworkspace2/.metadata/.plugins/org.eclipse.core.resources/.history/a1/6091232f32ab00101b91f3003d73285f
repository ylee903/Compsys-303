#include <string.h>
#include <stdio.h>
#include <sys/alt_alarm.h>
#include <sys/alt_ticks_per_second.h>
#include <altera_avalon_pio_regs.h>
#include <system.h>

#include "Pacemaker_C.h"

/* ----------------- Module-local 1ms ticker ----------------- */
static volatile alt_u32 s_ms_ticks = 0;
static alt_alarm s_alarm;
static int s_banner_printed = 0;

/* Re-arm close to 1 ms using the system tick rate */
static alt_u32 PMc_alarm_cb(void* ctx) {
  (void)ctx;
  s_ms_ticks++;
  alt_u32 tps = alt_ticks_per_second();
  if (tps == 0) tps = 1000;               /* fallback */
  alt_u32 per = tps / 1000;
  if (per == 0) per = 1;                  /* at least 1 tick */
  return per;
}

int PMc_start_1ms_alarm(void) {
  alt_u32 tps = alt_ticks_per_second();
  if (tps == 0) tps = 1000;
  alt_u32 per = tps / 1000;
  if (per == 0) per = 1;
  int r = alt_alarm_start(&s_alarm, per, PMc_alarm_cb, NULL);
  if (!s_banner_printed) {
    s_banner_printed = 1;
    printf("[C-MODE] C pacemaker running (ISR ~1ms tick active)\n");
    fflush(stdout);
  }
  return r;
}

static void dec_if_pos(int* t) { if (*t > 0) (*t)--; }

/* ----------------- Public API ----------------- */

void PMc_init(PacemakerC* s) {
  memset(s, 0, sizeof(*s));
  s->led_pulse_ms = 25;   /* default visibility */
  /* Start with LRI running so backup VP will eventually occur */
  s->LRI = LRI_VALUE;
}

void PMc_set_led_pulse_ms(PacemakerC* s, int ms) {
  s->led_pulse_ms = (ms > 0 ? ms : 1);
}

void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw) {
  s->AS_raw = AS_raw;
  s->VS_raw = VS_raw;

  /* Sanity button: KEY2 (active-low) prints a confirmation that C-mode is alive */
#ifdef KEYS_BASE
  {
    alt_u32 keys = IORD_ALTERA_AVALON_PIO_DATA(KEYS_BASE);
    if ((keys & 0x04) == 0) {
      printf("[C-MODE] Sanity button (KEY2) pressed — C version confirmed running.\n");
      fflush(stdout);
    }
  }
#endif
}

/* ----------------- Core 1-ms algorithm step ----------------- */

static void PMc_tick_1ms(PacemakerC* s) {
  /* Decrement timers and LED stretch */
  dec_if_pos(&s->AVI);   dec_if_pos(&s->AEI);   dec_if_pos(&s->PVARP);
  dec_if_pos(&s->VRP);   dec_if_pos(&s->LRI);   dec_if_pos(&s->URI);
  dec_if_pos(&s->AP_led_ms); dec_if_pos(&s->VP_led_ms);

  /* Gate senses by refractory */
  s->AS = (s->AS_raw && s->PVARP == 0);
  s->VS = (s->VS_raw && s->VRP   == 0);

  /* Default outputs this ms */
  s->AP = 0; s->VP = 0;

  /* ---------------- Intrinsic events first ---------------- */
  if (s->VS) {
    /* A real V happened → reset V-related timers and cancel any pending VP */
    s->VRP = VRP_VALUE;
    s->PVARP = PVARP_VALUE;          /* PVARP starts only after V events */
    s->AEI = AEI_VALUE;
    s->LRI = LRI_VALUE;
    s->URI = URI_VALUE;
    s->seen_AS_since_last_V = 0;

    s->AVI = 0;                      /* inhibit any AVI-based pending */
    s->pending_vp_avi = 0;           /* cancel AVI-pending */
    s->pending_vp_lri = 0;           /* cancel LRI-pending */
    s->vp_waiting_for_URI = 0;       /* derived flag (kept for debug) */
  }

  if (s->AS) {
    /* NOTE: Do NOT start PVARP here; PVARP is post-VENTRICULAR. */
    s->AVI   = AVI_VALUE;            /* start A->V interval */
    s->seen_AS_since_last_V = 1;
  }

  /* --------------- Atrial pacing on AEI timeout --------------- */
  if (s->AEI == 0 && s->seen_AS_since_last_V == 0) {
    s->AP = 1; s->AP_fired = 1; s->AP_led_ms = s->led_pulse_ms;
    /* AP behaves like an atrial event (but still does NOT start PVARP) */
    s->AVI   = AVI_VALUE;
    s->seen_AS_since_last_V = 1;
  }

  /* ---------------- Ventricular pacing desire ---------------- */
  {
    int want_vp_avi = 0;
    int want_vp_lri = 0;

    /* AVI-based desire: only once per A-event (don't re-trigger every ms) */
    if (s->seen_AS_since_last_V && s->AVI == 0 && !s->pending_vp_avi) {
      want_vp_avi = 1;
    }

    /* LRI-based desire: only once per LRI expiration window */
    if (s->LRI == 0 && !s->pending_vp_lri) {
      want_vp_lri = 1;
    }

    /* Aggregate desire */
    if (want_vp_avi || want_vp_lri) {
      if (s->URI == 0) {
        /* URI allows pacing now */
        s->VP = 1; s->VP_fired = 1; s->VP_led_ms = s->led_pulse_ms;

        /* Start/restart V-related timers */
        s->VRP = VRP_VALUE;
        s->PVARP = PVARP_VALUE;      /* PVARP starts on VP too */
        s->AEI = AEI_VALUE;
        s->LRI = LRI_VALUE;
        s->URI = URI_VALUE;

        /* Close the A->V loop */
        s->AVI = 0;
        s->seen_AS_since_last_V = 0;

        /* Clear all pendings and debug flag */
        s->pending_vp_avi = 0;
        s->pending_vp_lri = 0;
        s->vp_waiting_for_URI = 0;
      } else {
        /* Hold-off due to URI: remember *which* reason(s) caused desire */
        if (want_vp_avi) s->pending_vp_avi = 1;
        if (want_vp_lri) s->pending_vp_lri = 1;
        s->vp_waiting_for_URI = 1;
      }
    }

    /* If we owe a VP but were blocked by URI, fire when URI expires */
    if ((s->pending_vp_avi || s->pending_vp_lri) && s->URI == 0) {
      s->VP = 1; s->VP_fired = 1; s->VP_led_ms = s->led_pulse_ms;

      s->VRP = VRP_VALUE;
      s->PVARP = PVARP_VALUE;        /* PVARP starts on VP */
      s->AEI = AEI_VALUE;
      s->LRI = LRI_VALUE;
      s->URI = URI_VALUE;

      s->AVI = 0; s->seen_AS_since_last_V = 0;

      s->pending_vp_avi = 0;
      s->pending_vp_lri = 0;
      s->vp_waiting_for_URI = 0;
    }
  }

  /* Raw senses are one-ms pulses; clear after consumption */
  s->AS_raw = 0; s->VS_raw = 0;
}

/* ----------------- Scheduler-facing helpers ----------------- */

void PMc_run_for_elapsed_ms(PacemakerC* s) {
  while (s_ms_ticks) {
    PMc_tick_1ms(s);
    s_ms_ticks--;
  }
}

void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any) {
  if (AP_any) *AP_any = s->AP_fired;
  if (VP_any) *VP_any = s->VP_fired;
  s->AP_fired = 0;
  s->VP_fired = 0;
}

int PMc_led_AP_on(const PacemakerC* s) { return (s->AP_led_ms > 0); }
int PMc_led_VP_on(const PacemakerC* s) { return (s->VP_led_ms > 0); }
