// =============================================
// File: Pacemaker_C.h
// =============================================
#ifndef PACEMAKER_C_H
#define PACEMAKER_C_H

#include <alt_types.h>
#include "timing.h"  // AVI_VALUE, AEI_VALUE, PVARP_VALUE, VRP_VALUE, LRI_VALUE, URI_VALUE

#ifdef __cplusplus
extern "C" {
#endif

// Hand-written DDD pacemaker state for C mode (SW0 = 1)
typedef struct {
  // Inputs for current ms (raw/ungated). Caller sets these before stepping.
  int AS_raw;   // atrial sense (1 = a-sensed at this ms)
  int VS_raw;   // ventricular sense (1 = v-sensed at this ms)

  // Internal, gated senses (after refractory)
  int AS;       // becomes 1 for this ms if AS_raw && !PVARP
  int VS;       // becomes 1 for this ms if VS_raw && !VRP

  // One-ms pace pulses generated by the algorithm (set during a tick)
  int AP;       // atrial pace at this ms
  int VP;       // ventricular pace at this ms

  // Sticky flags to report if a pace happened in any processed ms since last poll
  int AP_fired;
  int VP_fired;

  // Timers (countdown, ms; 0 = expired/not running)
  int AVI, AEI, PVARP, VRP, LRI, URI;

  // Control flags
  int seen_AS_since_last_V;   // true if any A-event (AS or AP) since the last V-event
  int vp_waiting_for_URI;     // we owe a VP but are blocked by URI

  // LED stretch (visual only, does not affect protocol)
  int led_pulse_ms;           // configurable, default 25 ms
  int AP_led_ms;              // remaining ms to hold AP LED on
  int VP_led_ms;              // remaining ms to hold VP LED on
} PacemakerC;

// ---- Lifecycle ----
void PMc_init(PacemakerC* s);
void PMc_set_led_pulse_ms(PacemakerC* s, int ms);

// ---- 1 ms timing ----
// Start a 1ms alarm that increments an internal tick counter (module-local ISR)
int  PMc_start_1ms_alarm(void);
// Run the algorithm once per elapsed ms (consumes any accumulated ISR ticks)
void PMc_run_for_elapsed_ms(PacemakerC* s);

// ---- Inputs for next ms window ----
// Caller sets raw senses before calling PMc_run_for_elapsed_ms(). These are
// treated as single-ms pulses when set to 1.
static inline void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw){ s->AS_raw = AS_raw; s->VS_raw = VS_raw; }

// ---- Outputs / status ----
// After PMc_run_for_elapsed_ms(), query whether any AP/VP fired during the
// processed window; this also clears the sticky flags.
void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any);

// LED helpers: whether LEDs should currently be on (with stretch applied)
int PMc_led_AP_on(const PacemakerC* s);
int PMc_led_VP_on(const PacemakerC* s);

#ifdef __cplusplus
}
#endif

#endif // PACEMAKER_C_H


// =============================================
// File: Pacemaker_C.c
// =============================================
#include <string.h>
#include <sys/alt_alarm.h>
#include "Pacemaker_C.h"

// Module-local 1ms ticker
static volatile alt_u32 s_ms_ticks = 0;
static alt_alarm s_alarm;

static alt_u32 PMc_alarm_cb(void* ctx){ (void)ctx; s_ms_ticks++; return 1; }

int PMc_start_1ms_alarm(void){
  // Start at 1-tick period (Platform/BSP tick is 1 ms)
  return alt_alarm_start(&s_alarm, 1, PMc_alarm_cb, NULL);
}

static inline void dec_if_pos(int* t){ if (*t > 0) (*t)--; }

void PMc_init(PacemakerC* s){
  memset(s, 0, sizeof(*s));
  s->led_pulse_ms = 25; // default visibility
  // Initial timers: LRI running so backup VP will eventually occur
  s->LRI = LRI_VALUE;
}

void PMc_set_led_pulse_ms(PacemakerC* s, int ms){ s->led_pulse_ms = (ms > 0 ? ms : 1); }

// One 1-ms algorithm step
static void PMc_tick_1ms(PacemakerC* s){
  // Decrement timers and LED stretch
  dec_if_pos(&s->AVI); dec_if_pos(&s->AEI); dec_if_pos(&s->PVARP);
  dec_if_pos(&s->VRP); dec_if_pos(&s->LRI); dec_if_pos(&s->URI);
  dec_if_pos(&s->AP_led_ms); dec_if_pos(&s->VP_led_ms);

  // Gate senses by refractory
  s->AS = (s->AS_raw && s->PVARP == 0);
  s->VS = (s->VS_raw && s->VRP   == 0);

  // Default outputs this ms
  s->AP = 0; s->VP = 0;

  // --- Intrinsic events first ---
  if (s->VS){
    s->VRP = VRP_VALUE;
    s->AEI = AEI_VALUE;
    s->LRI = LRI_VALUE;
    s->URI = URI_VALUE;
    s->seen_AS_since_last_V = 0;
    s->AVI = 0;                 // inhibit pending AVI-based VP
    s->vp_waiting_for_URI = 0;  // cancel pending VP
  }
  if (s->AS){
    s->PVARP = PVARP_VALUE;
    s->AVI   = AVI_VALUE;       // start Aâ†’V interval
    s->seen_AS_since_last_V = 1;
  }

  // --- Atrial pacing on AEI timeout (if no AS since last V) ---
  if (s->AEI == 0 && s->seen_AS_since_last_V == 0){
    s->AP = 1; s->AP_fired = 1; s->AP_led_ms = s->led_pulse_ms;
    // AP behaves like an atrial event
    s->PVARP = PVARP_VALUE;
    s->AVI   = AVI_VALUE;
    s->seen_AS_since_last_V = 1;
  }

  // --- Ventricular pacing desire ---
  int want_VP = 0;
  if (s->AVI == 0 && s->seen_AS_since_last_V){ want_VP = 1; }
  if (s->LRI == 0){ want_VP = 1; }

  if (want_VP){
    if (s->URI == 0){
      s->VP = 1; s->VP_fired = 1; s->VP_led_ms = s->led_pulse_ms;
      s->VRP = VRP_VALUE; s->AEI = AEI_VALUE; s->LRI = LRI_VALUE; s->URI = URI_VALUE;
      s->AVI = 0; s->vp_waiting_for_URI = 0; s->seen_AS_since_last_V = 0;
    } else {
      s->vp_waiting_for_URI = 1;
    }
  }

  // If we owe a VP but were blocked by URI, pace as soon as it expires
  if (s->vp_waiting_for_URI && s->URI == 0){
    s->VP = 1; s->VP_fired = 1; s->VP_led_ms = s->led_pulse_ms;
    s->VRP = VRP_VALUE; s->AEI = AEI_VALUE; s->LRI = LRI_VALUE; s->URI = URI_VALUE;
    s->AVI = 0; s->vp_waiting_for_URI = 0; s->seen_AS_since_last_V = 0;
  }

  // Raw senses are single-ms pulses; clear after consumption
  s->AS_raw = 0; s->VS_raw = 0;
}

void PMc_run_for_elapsed_ms(PacemakerC* s){
  while (s_ms_ticks){
    PMc_tick_1ms(s);
    s_ms_ticks--;
  }
}

void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any){
  if (AP_any) *AP_any = s->AP_fired; if (VP_any) *VP_any = s->VP_fired;
  s->AP_fired = 0; s->VP_fired = 0;
}

int PMc_led_AP_on(const PacemakerC* s){ return s->AP_led_ms > 0; }
int PMc_led_VP_on(const PacemakerC* s){ return s->VP_led_ms > 0; }
