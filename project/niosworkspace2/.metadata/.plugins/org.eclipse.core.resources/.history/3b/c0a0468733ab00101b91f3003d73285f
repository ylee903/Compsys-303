#include "Pacemaker_C.h"
#include <string.h>

/* ---------- helpers ---------- */
static inline void dec_if_pos(int* t) { if (*t > 0) (*t)--; }

/* ---------- public: lifecycle ---------- */
void PMc_init(PacemakerC* s) {
  if (!s) return;
  memset(s, 0, sizeof(*s));

  /* Defaults (only the V-side is active in Case 2) */
  s->AVI = 0;
  s->AEI = 0;
  s->PVARP = 0;
  s->VRP = 0;
  s->LRI = 0;
  s->URI = 0;

  s->v_since_current_A = 1;   /* no A yet, treat as if V already occurred */
  s->pending_vp_avi = 0;

  s->led_pulse_ms = 0;
  s->AP_led_ms = s->VP_led_ms = 0;
}

void PMc_set_led_pulse_ms(PacemakerC* s, int ms) {
  if (!s) return;
  s->led_pulse_ms = (ms > 0 ? ms : 0);
}

/* No hardware timers in this drop: pretend success */
int PMc_start_1ms_alarm(void) { return 0; }

/* Caller should set AS_raw/VS_raw before calling this each 1 ms */
void PMc_set_senses(PacemakerC* s, int AS_raw, int VS_raw) {
  if (!s) return;
  s->AS_raw = AS_raw ? 1 : 0;
  s->VS_raw = VS_raw ? 1 : 0;
}

/* ---------- core 1 ms step (Case 2) ---------- */
static void PMc_tick_1ms(PacemakerC* s) {
  /* clear one-tick outputs */
  s->AP = 0; s->VP = 0;

  /* decrement timers */
  dec_if_pos(&s->AVI);
  dec_if_pos(&s->AEI);
  dec_if_pos(&s->PVARP);
  dec_if_pos(&s->VRP);
  dec_if_pos(&s->LRI);
  dec_if_pos(&s->URI);
  dec_if_pos(&s->AP_led_ms);
  dec_if_pos(&s->VP_led_ms);

  /* gate senses by refractory */
  s->AS = (s->AS_raw && s->PVARP == 0) ? 1 : 0;  /* PVARP gates AS */
  s->VS = (s->VS_raw && s->VRP   == 0) ? 1 : 0;  /* VRP   gates VS */

  /* ---------- handle intrinsic VS first ---------- */
  if (s->VS) {
    /* a ventricular depolarization happened (junctional/AV) */
    s->VRP = VRP_VALUE;
    s->PVARP = PVARP_VALUE;     /* PVARP starts after any V event */
    s->URI = URI_VALUE;

    s->v_since_current_A = 1;
    s->pending_vp_avi = 0;      /* if we owed a VP, cancel due to VS */
    s->AVI = 0;                 /* close out any running AVI */
  }

  /* ---------- handle atrial sensed events ---------- */
  if (s->AS) {
    /* New atrial event — start (or restart) the A→V interval window */
    s->AVI = AVI_VALUE;
    s->v_since_current_A = 0;   /* waiting for a V following this A */
  }

  /* ---------- ventricular pacing desire (AVI-driven) ---------- */
  if (!s->v_since_current_A) {
    if (s->AVI == 0) {
      /* We owe a VP unless blocked by URI */
      if (s->URI == 0) {
        /* Pace the ventricle to restore A–V synchrony */
        s->VP = 1;
        s->VP_fired = 1;
        s->VP_led_ms = s->led_pulse_ms;

        /* V-timers after VP */
        s->VRP = VRP_VALUE;
        s->PVARP = PVARP_VALUE;
        s->URI = URI_VALUE;

        s->v_since_current_A = 1;
        s->pending_vp_avi = 0;
        s->AVI = 0;
      } else {
        /* Hold until URI expires; keep the debt */
        s->pending_vp_avi = 1;
      }
    }
  }

  /* ---------- late release if URI was blocking ---------- */
  if (s->pending_vp_avi && s->URI == 0 && !s->v_since_current_A) {
    /* URI cleared and no intrinsic V has happened: deliver VP now */
    s->VP = 1;
    s->VP_fired = 1;
    s->VP_led_ms = s->led_pulse_ms;

    s->VRP = VRP_VALUE;
    s->PVARP = PVARP_VALUE;
    s->URI = URI_VALUE;

    s->v_since_current_A = 1;
    s->pending_vp_avi = 0;
    s->AVI = 0;
  }

  /* raw senses are one-ms pulses; clear for next step */
  s->AS_raw = 0;
  s->VS_raw = 0;
}

/* Advance exactly one 1 ms step per call */
void PMc_run_for_elapsed_ms(PacemakerC* s) {
  if (!s) return;
  PMc_tick_1ms(s);
}

/* ---------- outputs / status ---------- */
void PMc_poll_and_clear_pulses(PacemakerC* s, int* AP_any, int* VP_any) {
  if (AP_any) *AP_any = s->AP_fired;
  if (VP_any) *VP_any = s->VP_fired;
  if (!s) return;
  s->AP_fired = 0;
  s->VP_fired = 0;
}

int PMc_led_AP_on(const PacemakerC* s) { (void)s; return 0; }
int PMc_led_VP_on(const PacemakerC* s) { return (s && s->VP_led_ms > 0) ? 1 : 0; }
